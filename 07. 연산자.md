#  연산자



## 	1. 표현식과 연산자

표현식은 리터럴, 식별자, 연산자, 함수 호출 등의 조합을 말한다. 

표현식은 평가되어 하나의 값을 만듬. 즉 표현식은 하나의 값으로 평가될 수 있는 문이다. 

표현식은 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메소드 호출 표현식 등으로 나누어 볼 수 있지만 결국 평가되어 하나의 값을 만든다는 점에서 모두 동일하다.

> // 리터럴 표현식
>
> 10

> // 식별자 표현식 
>
> sum

> // 연산자 표현식
>
> 10 + 20

> // 함수/메소드 호출 표현식
>
> square()

> var x  = 10;
>
> // 연산자 표현식
>
> x + 30;  // 식별자 표현식과 숫자 리터럴과 연산자의 조합

* 표현식은 평가되어 결국 하나의 값이 되므로 표현식과 값은 동등한 관계이다.
* 표현식은 값처럼 사용 가능
* 이것은 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있음



## 2. 문과 표현식

문은 자바스크립트 엔진에게 내리는 명령이다. 문이 실행되면 무슨 일인가가 일어나게 됨.

변수 선언문을 실행하면 변수가 선언이 되고, 할당문을 실행하면 할당이 된다. 조건문을 실행하면 주어진 조건에 따라 코드 블록({...})의 실행이 결정, 반복문을 실행파면 코드 블록이 반복 실행된다.

> // 변수 선언문
>
> var x;

> // 할당문
>
> x = 5;

> // 함수 선언문
>
> function foo ( ) { }

> // 조건문
>
> if (x > 5) { ... }

> // 반복문
>
> for ( var i = 0; i < 10; i++) { ... }

문은 리터럴, 연산자, 표현식, 키워드 등으로 구성되며 세미콜론( ; )으로 끝나야 함.(코드블록 { ... }은 제외)

문의 끝에 붙이는 세미콜론은 옵션으로 쓰지 않아도 상관 X , 자바 스크립트는 엔진이 스크립트를 해석할 때, 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 **세미콜론 자동 삽입 기능**이 있다. 하지만 세미콜론 자동 삽입 기능의 예측과 개발자의 예측과 다른 경우도 있다.  

문 :  `var` ,`let` ,`const`, `function` , `class`와 같은 선언 키워드를 사용하여 변수나 함수 생성 , `if`, `for`, `while` 문과 같은 제어문을 생성하여 프로그램의 흐름 제어하기도 함, 표현식으로 생성한 값을 사용해 컴퓨터에게 명령을 내림

표현식 :  문을 구성하는 요소 , 값을 생성함 

> 선언문
>
> var x = 5 * 10;	// **표현식** x = 5 * 10을 **포함**하는 **문** , 값처럼 사용 X

> 할당문
>
> x = 100;	// **표현식**이면서도 **완전한 문** , 값처럼 사용 가능
>
> var foo = x = 100;	// 값처럼 변수에 할당, 할당한 값으로 평가 , `x = 100`은 변수 x에 할당한 값 100으로 평가 따라서 변수 foo에 100 할당



## 3. 연산자란?

: 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 등을 수행해 하나의 값을 만드는 것

피연산자 : **연산의 대상**이 되어야 함으로 **값**으로 평가할 수 있어야 함

피연산자는 "값"이라는 **명사**의 역할이라면 연산자는 "값을 만든다"라는 **동사**의 역할을 함 

> 산술 연산자
>
> 5 * 4	// 20

> 문자열 연결 연산자
>
> 'My name is ' + 'Lee'	// "My name is Lee"

> 할당 연산자
>
> var color = 'red' ;	// "red"

> 비교 연산자
>
> 3 > 5	// false

> 논리 연산자
>
> (5 > 3) && (2 > 4)	// true

> 타입 연산자
>
> typeof 'Hi'	// "string"



### 4. 산술 연산자

산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 값을 만듦 산술 연산을 할 수 없는 경우에는 NaN을 반환함. NaN : 값이 숫자가 아니다

* 이항 산술 연산자

  2개의 피연산자를 대상으로 연산하여 숫자 타입의 값을 만듦

  어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우 X , 새로운 값을 만들 뿐

  | 이항 산술 연산자 | 의미   |
  | :--------------: | ------ |
  |        +         | 덧셈   |
  |        -         | 뺄셈   |
  |        *         | 곱셈   |
  |        /         | 나눗셈 |
  |        %         | 나머지 |



* 단항 산술 연산자

  1개의 피연산자를 대상으로 연산 

  증가 / 감소 연산을 하면 피연산자의 값이 바뀜

  ​		증가 감소 연산자는 위치에 따라 순서가 달라짐

  ​		앞에 위치하면 전위 증가 / 감소 연산자 (먼저 피연산자의 값을 증가 / 감소시킨 후, 다른 연산을 수행)

  ​		뒤에 위치하면 후위 증가 / 감소 연산자 (먼저 다른 연산을 수행한 후, 피연산자의 값을 증가 / 감소)

| 단항 산술 연산자 | 의미                                         |
| :--------------: | -------------------------------------------- |
|        ++        | 증가                                         |
|        --        | 감소                                         |
|        +         | 효과 X                                       |
|        -         | 양수는 음수로 음수는 양수로 반전한 값을 반환 |

> 1 + 2	// 3>
>
> 1 + true	// 2 ( true = 1)
>
> 1 + false	// 1 ( false = 0)
>
> true + false	// 1 ( true = 1 / flase = 0 )
>
> 1 + null	// 1 ( null = 0 )
>
> 1 + undefined	// NaN ( undefined = NaN)



* 문자열 연결 연산자

`+` 연산자는 **피연산자 중 하나 이상이 문자열**인 경우 **문자열 연결 연산자**로 동작 

> '1' + '2'	// '12'
>
> '1' + 2	// '12'



### 5. 할당 연산자

: 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당 ,  변수에 값을 할당하는 부수 효과가 있음 ( 부수 효과 : 피연산자의 값을 변경시키는 것을 의미 )

| 할당연산자 |  사례  | 동일 표현 |
| :--------: | :----: | :-------: |
|     =      | x = y  |   x = y   |
|     +=     | x += y | x = x + y |
|     -=     | x -= y | x = x - y |
|     *=     | x *= y | x = x * y |
|     /=     | x /= y | x = x / y |
|     %=     | x %= y | x = x % y |



### 6. 비교 연산자

: 좌항과 우항의 피연산자를 비교하여 불리언 값을 반환, `if`문이나 `for`문과 같은 제어문의 조건식에서 주로 사용

* 동등 / 일치 비교 연산자

  | 비교 연산자 |    의미     |  사례   |           설명           |
  | :---------: | :---------: | :-----: | :----------------------: |
  |     ==      |  동등 비교  | x == y  |    x와 y의 값이 같음     |
  |     ===     |  일치 비교  | x === y | x와 y의 값과 타입이 같음 |
  |     !=      |  부등 비교  | x != y  |    x와 y의 값이 다름     |
  |     !==     | 불일치 비교 | x !== y | x와 y의 값과 타입이 다름 |



> ' ' == '0'	// false
>
> 0 == ' '	// true
>
> 0 == '0'	// true

> flase == 'false'	// flase
>
> flase == '0'	// true

> false == indefined	// false
>
> false == null	// flase
>
> null == undefined	// true

> 5 === 5	// true
>
> 5 === '5'	// false



* 대소 관계 비교 연산자

  : 피연산자의 크기를 비교하여 불리언 값을 반환

  | 대소관계비교연산자 | 예제 |          설명           |
  | :----------------: | :--: | :---------------------: |
  |         >          | x>y  |    x가 y보다 크다 X     |
  |         <          | x<y  |    x가 y보다 작다 X     |
  |         >=         | x>=y | x가 y보다 가거나 크다 X |
  |         <=         | x<=y | x가 y보다 같거나 크다 X |

  

### 7. 삼항 조건 연산자

: 조건식의 평가 결과에 다라 반환할 값을 결정

>  `조건식`  ?  `조건식이 true일 때 반활할 값`  :  `조건식이 false일 때 반활할 값`

* 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환이 된다.
* if...else 문도 동일한 처리가 가능하지만, 표현식이 아닌 문이다. 따라서 if...else 문은 값으로 평가 X
* 다른 표현식의 일부가 될 수 있어 매우 유용



### 8. 논리 연산자

: 우항과 좌항의 피연산자를 논리 연산한다.

| 논리 연산자 |    의미     |
| :---------: | :---------: |
|    \|\|     | 논리합(OR)  |
|     &&      | 논리곱(AND) |
|      !      |  부정(NOT)  |

* 논리 부정`! ` 연산자는 언제나 불리언 값을 반환한다.
* 논리합 `||` 연산자와 논리곱 `&&` 연산자의 연산 결과의 불리언 값이 아닐 수도 있다.



### 9. 쉼표 연산자

: 쉼표`,` 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가 , 마지막 피연산자의 평가가 끝나면 **마지막 피연산자**의 평가 결과를 반환함

> var x, y, z;
>
> x = 1, y = 2, z = 3;	// 3



### 10. 그룹 연산자

그룹 `...`연산자는 그룹 내의 표현식을 최우선으로 평가 , 그룹 연산자를 사용하면 연산자의 우선 순위를 1순위로 높일 수 있음



### 11. typeof 연산자

: 자신의 뒤에서 위치한 피연산자의 데이터 타입을 문자열로 반환,  반환된 문자열은 7개의 데이터 타입과 X, typeof 연산자는 7가지 문자열 "string", "number", "boolean", "undefined", "symbol", "object", "function" 중 하나를 반환

"null"을 반환하는 경우는 X , 함수의 경우 "function"을 반환

null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용

선언하지 않은 식별자를 typeof 연산자로 연산해 보면 Error가 아닌 "undefined"를 반환

> typeof ' '	//  "string"
>
> typeof 1	// "number"
>
> typeof NaN	// "number"
>
> typeof true	// "boolean"
>
> typeof undefined	// "undefined"
>
> typeof Symbol()	// "symbol"
>
> typeof null	// "object"
>
> typeof []	// "object"
>
> typeof {}	// "object"
>
> typeof new Date( )	// "object"
>
> typeof /test/gi	// "object"
>
> typeof function ( ) { }	// "function"