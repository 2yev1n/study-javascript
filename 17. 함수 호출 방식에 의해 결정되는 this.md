# 함수 호출 방식에 의해 결정되는 this

자바스크립트의 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에, **arguments 객체**와 **`this`**를 암묵적으로 전달 받는다.

> function square(number) {
>
> ​	console.log(arguments);
> ​	console.log(this);
>
> ​	return number * number;
> }
>
> square(2);

자바스크립트의 `this` keyword는 Java와 같은 익숙한 언어의 개념과 달라 개발자에게 혼란을 준다



### 함수 호출 방식과 this 바인딩

자바스크립트의 경우 함수 호출 방식에 의해 `this` 에 바인딩할 어떤 객체가 동적으로 결정 다시 말해, 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고,  **함수를 호출할 때 함수가 어떻게 호출되었는지에 따라** this에 바인딩할 객체가 동적으로 결정

함수의 호출하는 방식은 아래와 같이 다양하다.

1. 함수 호출
2. 메소드 호출
3. 생성자 함수 호출
4. apply / call / bind 호출

> var foo = function () {
>
> ​	console.dir(this);
>
> };
>
> // 1. 함수 호출
> foo();		// window
> // window.foo();
>
> // 2. 메소드 호출
> var obj = { foo: foo };
> obj.foo();		// obj
>
> // 3. 생성자 함수 호출
> var instance = new foo();		// instance
>
> // 4. apply / call / bind 호출
> var bar = { name: 'bar' };
> foo.call(bar);			 // bar
> foo.apply(bar);		 // bar
> foo.bind(bar)();	    // bar



### 1. 함수 호출

전역객체는 모든 객체의 유일한 최상위 객체를 의미하여 일반적으로 Browser-side에서는 `window` , Server-side(Node.js)에서는 `global` 객체를 의미

> // in browser console
> this === window		   // ture
>
> // in Terminal
> node
> this === global 			// true

전역객체는 전역 스코프를 갖는 전역변수를 프로퍼티로 소유한다. 글로벌 영역에 선언한 함수는 전역객체의 프로퍼티로 접근할 수 있는 전역 변수의 메소드이다.

기본적으로 `this` 는 전역객체에 바인딩된다. 전역함수는 물론이고 심지어 내부함수의 경우도  this는 외부함수가 아닌 전역객체에 바인딩된다. 또한 메소드의 내부함수, 콜백함수일 경우에도 `this` 는 전역객체에 바인딩된다.

**내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든 관계없이 this는 전역객체를 바인딩한다.** 

![Function Invocation Pattern](https://poiemaweb.com/img/Function_Invocation_Pattern.png)

자바스크립트는 this를 명시적으로 바인딩할 수 있는 apply, call, bind 메소드를 제공

> var value = 1;
>
> var obj = {
>
> ​	value: 100,
>
> ​	foo: function() {
>
> ​		console.log("foo's this: ", this);		// obj
> ​		console.log("foo's this.value:  ", this.value);		// 100
> ​		function bar(a, b) {
> ​			console.log("bar's this:  ", this);		// obj
> ​			console.log("bar's this.value:  ", this.value);		// 100
> ​			console.log("bar's arguments:  ", arguments);
> ​		}
> ​		bar.apply(obj, [1, 2]);
> ​		bar.call(obj, 1, 2);
> ​		bar.bind(obj)(1, 2);
> ​	}
> };



### 2. 메소드 호출

함수가 객체의 프로퍼티 값이면 메소드로서 호출된다. 이때 메소드 내부의 `this` 는 해당 메소드를 소유한 객체, 즉 해당 메소드를 호출한 객체에 바인딩된다.

> var obj1 = {
>
> ​	name: 'Lee',
>
> ​	sayName: function() {
> ​		console.log(this.name);
> ​	}
> }
>
> var obj2 = {
> 	name: 'Kim'
> }
>
> obj.sayName = obj1.sayName;
>
> obj1.sayName();
> obj2.sayName();

![Method Invocation Pattern](https://poiemaweb.com/img/Method_Invocation_Pattern.png)

프로토타입 객체도 메소드를 가질 수 있다. 프로토타입 객체 메소드 내부에서 사용된 this도 일반 메소드 방식과 마찬가지로 해당 메소드를 호출한 객체에 바인딩된다.

